1/ Créer un système de création / déconstruction de chunk dynamique ( ~1 Go de Ram)
	- Utilisation d'une liste d'attente de taille fixe
	- Un index uniform attribué pour chaque element fixe de la liste d'attente
	- Utilisation propice aux threads
2/ Optimiser la taille des vertex
	- 8 bits pour le type (couleur encodé in-shader) [0;255]
	- 5 bits * 3 pour les coordonnées [0;31]
	- 15 bits pour l'index uniform du chunk
	- Uniform de 32 bits
	- Normal de la face directement dans le vbo statique des vertices
3/ Optimisation du vertex polling (caméra)
	- Frustrum chunks culling
	- Faces culling
	- Proximity Sorting (Tri en profondeur)
4/ Mise en cache
	- Octotrees et compteur de voxel
5/ Optimisation des détails - LOD (Level of detail)
	- Utilisation d'une variance du vbo des vertices
	- Voxel de taille 2*2 ou 4*4 selon leurs distances
6/ Variance de couleur in-shader
	- Plague [-3;3] avec utilisation de glFragment position
	- Fonction sin modifiée
7/ Changement dynamique dans les buckets en multi-threading
	- 1 index de buckets fixes pour chaque element chunk
	- Stockage d'une liste d'index de voxels vers un pointeur	[DataPointer, IndexPointer] (default = [DataPointer, currentPointer] )
	- UShort / UInt
10 / Lighting https://web.archive.org/web/20200319071420/http://codeflow.org/entries/2010/dec/09/minecraft-like-rendering-experiments-in-opengl-4/

